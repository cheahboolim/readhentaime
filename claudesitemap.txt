// src/routes/sitemap.xml/+server.ts - MAIN INDEX
import { supabase } from '$lib/supabaseClient';

const SITE_URL = 'https://nhentai.pics';
const URLS_PER_SITEMAP = 25000;

export async function GET() {
  try {
    const sitemaps = [];

    // Static pages sitemap
    sitemaps.push({
      loc: `${SITE_URL}/sitemaps/sitemap-static.xml`,
      lastmod: new Date().toISOString().split('T')[0]
    });

    // Browse categories sitemaps (one per category type)
    const categoryTypes = ['tags', 'artists', 'categories', 'parodies', 'characters', 'languages', 'groups'];
    for (const categoryType of categoryTypes) {
      sitemaps.push({
        loc: `${SITE_URL}/sitemaps/sitemap-browse-${categoryType}.xml`,
        lastmod: new Date().toISOString().split('T')[0]
      });
    }

    // Manga galleries sitemap (chunked)
    const { count: totalManga } = await supabase
      .from('slug_map')
      .select('slug', { count: 'exact', head: true })
      .not('slug', 'is', null)
      .neq('slug', '');

    const galleryChunks = Math.ceil((totalManga || 0) / URLS_PER_SITEMAP);
    for (let i = 0; i < galleryChunks; i++) {
      sitemaps.push({
        loc: `${SITE_URL}/sitemaps/sitemap-manga-galleries-${i}.xml`,
        lastmod: new Date().toISOString().split('T')[0]
      });
    }

    // Reading pages sitemaps (chunked)
    const { count: totalPages } = await supabase
      .from('pages')
      .select('id', { count: 'exact', head: true })
      .not('manga_id', 'is', null);

    const pageChunks = Math.ceil((totalPages || 0) / URLS_PER_SITEMAP);
    const maxChunks = Math.min(pageChunks, 200); // Increased cap

    for (let i = 0; i < maxChunks; i++) {
      sitemaps.push({
        loc: `${SITE_URL}/sitemaps/sitemap-manga-pages-${i}.xml`,
        lastmod: new Date().toISOString().split('T')[0]
      });
    }

    const sitemapIndex = `<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${sitemaps.map(sitemap => `  <sitemap>
    <loc>${sitemap.loc}</loc>
    <lastmod>${sitemap.lastmod}</lastmod>
  </sitemap>`).join('\n')}
</sitemapindex>`;

    return new Response(sitemapIndex, {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'max-age=86400'
      }
    });
  } catch (error) {
    console.error('Sitemap index generation error:', error);
    
    // Fallback minimal sitemap
    const fallbackSitemaps = [
      {
        loc: `${SITE_URL}/sitemaps/sitemap-static.xml`,
        lastmod: new Date().toISOString().split('T')[0]
      }
    ];

    const fallbackIndex = `<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${fallbackSitemaps.map(sitemap => `  <sitemap>
    <loc>${sitemap.loc}</loc>
    <lastmod>${sitemap.lastmod}</lastmod>
  </sitemap>`).join('\n')}
</sitemapindex>`;

    return new Response(fallbackIndex, {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'max-age=3600'
      },
      status: 500
    });
  }
}

// ===================================================================
// src/routes/sitemaps/sitemap-browse-[categoryType]/+server.ts
// ===================================================================

import { supabase } from '$lib/supabaseClient';

const SITE_URL = 'https://nhentai.pics';
const PAGE_SIZE = 10;
const MAX_PAGES_PER_CATEGORY = 500; // Increased limit

interface SitemapUrl {
  loc: string;
  lastmod?: string;
  changefreq?: 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never';
  priority?: string;
}

// Define the mapping for each category type
const CATEGORY_CONFIGS = {
  tags: { table: 'tags', joinTable: 'manga_tags', idField: 'tag_id' },
  artists: { table: 'artists', joinTable: 'manga_artists', idField: 'artist_id' },
  categories: { table: 'categories', joinTable: 'manga_categories', idField: 'category_id' },
  parodies: { table: 'parodies', joinTable: 'manga_parodies', idField: 'parody_id' },
  characters: { table: 'characters', joinTable: 'manga_characters', idField: 'character_id' },
  languages: { table: 'languages', joinTable: 'manga_languages', idField: 'language_id' },
  groups: { table: 'groups', joinTable: 'manga_groups', idField: 'group_id' }
};

export async function GET({ params }) {
  const categoryType = params.categoryType;
  const config = CATEGORY_CONFIGS[categoryType];
  
  if (!config) {
    return new Response('Invalid category type', { status: 400 });
  }

  const urls: SitemapUrl[] = [];

  try {
    // Get all categories/tags/etc for this type
    const { data: categories } = await supabase
      .from(config.table)
      .select('id, slug')
      .not('slug', 'is', null)
      .neq('slug', '');

    if (categories) {
      for (const category of categories) {
        // Add the main category page
        urls.push({
          loc: `${SITE_URL}/browse/${categoryType}/${category.slug}`,
          lastmod: new Date().toISOString().split('T')[0],
          changefreq: 'daily',
          priority: '0.7'
        });

        // Count total manga for this category
        const { count: totalManga } = await supabase
          .from(config.joinTable)
          .select('manga_id', { count: 'exact', head: true })
          .eq(config.idField, category.id);

        // Add paginated URLs if there are multiple pages
        if (totalManga && totalManga > PAGE_SIZE) {
          const totalPages = Math.min(
            Math.ceil(totalManga / PAGE_SIZE),
            MAX_PAGES_PER_CATEGORY
          );

          // Add paginated URLs (starting from page 2)
          for (let page = 2; page <= totalPages; page++) {
            urls.push({
              loc: `${SITE_URL}/browse/${categoryType}/${category.slug}?page=${page}`,
              lastmod: new Date().toISOString().split('T')[0],
              changefreq: 'weekly',
              priority: '0.5'
            });
          }
        }
      }
    }

    const sitemap = generateSitemapXML(urls);

    return new Response(sitemap, {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'max-age=86400'
      }
    });
  } catch (error) {
    console.error(`Browse ${categoryType} sitemap error:`, error);
    return new Response(generateSitemapXML([]), {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'max-age=3600'
      }
    });
  }
}

function generateSitemapXML(urls: SitemapUrl[]): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${urls.map(url => `  <url>
    <loc>${url.loc}</loc>
    ${url.lastmod ? `<lastmod>${url.lastmod}</lastmod>` : ''}
    ${url.changefreq ? `<changefreq>${url.changefreq}</changefreq>` : ''}
    ${url.priority ? `<priority>${url.priority}</priority>` : ''}
  </url>`).join('\n')}
</urlset>`;
}

// ===================================================================
// src/routes/sitemaps/sitemap-manga-galleries-[index]/+server.ts - FIXED
// ===================================================================

import { supabase } from '$lib/supabaseClient';

const SITE_URL = 'https://nhentai.pics';
const URLS_PER_SITEMAP = 25000;

interface SitemapUrl {
  loc: string;
  lastmod?: string;
  changefreq?: 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never';
  priority?: string;
}

export async function GET({ params }) {
  const index = parseInt(params.index, 10);
  if (isNaN(index)) {
    return new Response('Invalid index', { status: 400 });
  }

  try {
    // FIXED: Removed the .limit(1000) that was capping your results
    const { data: mangaData } = await supabase
      .from('slug_map')
      .select(`
        slug,
        manga_id,
        manga!inner(created_at)
      `)
      .not('slug', 'is', null)
      .neq('slug', '')
      .order('manga_id') // Consistent ordering
      .range(index * URLS_PER_SITEMAP, (index + 1) * URLS_PER_SITEMAP - 1);

    const urls: SitemapUrl[] = [];

    if (mangaData) {
      for (const item of mangaData) {
        const manga = item.manga as any;
        const lastmod = manga?.created_at
          ? new Date(manga.created_at).toISOString().split('T')[0]
          : new Date().toISOString().split('T')[0];

        urls.push({
          loc: `${SITE_URL}/hentai/${item.slug}`,
          lastmod,
          changefreq: 'monthly',
          priority: '0.7'
        });
      }
    }

    const sitemap = generateSitemapXML(urls);

    return new Response(sitemap, {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'max-age=86400'
      }
    });
  } catch (error) {
    console.error(`Manga galleries sitemap ${index} error:`, error);
    return new Response(generateSitemapXML([]), {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'max-age=3600'
      }
    });
  }
}

function generateSitemapXML(urls: SitemapUrl[]): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${urls.map(url => `  <url>
    <loc>${url.loc}</loc>
    ${url.lastmod ? `<lastmod>${url.lastmod}</lastmod>` : ''}
    ${url.changefreq ? `<changefreq>${url.changefreq}</changefreq>` : ''}
    ${url.priority ? `<priority>${url.priority}</priority>` : ''}
  </url>`).join('\n')}
</urlset>`;
}

// ===================================================================
// src/routes/sitemaps/sitemap-manga-pages-[index]/+server.ts - COMPLETELY REWRITTEN
// ===================================================================

import { supabase } from '$lib/supabaseClient';

const SITE_URL = 'https://nhentai.pics';
const URLS_PER_SITEMAP = 25000;

interface SitemapUrl {
  loc: string;
  lastmod?: string;
  changefreq?: 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never';
  priority?: string;
}

export async function GET({ params }) {
  const index = parseInt(params.index, 10);
  if (isNaN(index)) {
    return new Response('Invalid index', { status: 400 });
  }

  try {
    const urls: SitemapUrl[] = [];
    const offset = index * URLS_PER_SITEMAP;
    
    // FIXED: Simplified approach - get pages directly with slug information
    const { data: pageData } = await supabase
      .from('pages')
      .select(`
        manga_id,
        page_number,
        manga!inner(
          created_at,
          slug_map!inner(slug)
        )
      `)
      .not('manga_id', 'is', null)
      .order('manga_id')
      .order('page_number')
      .range(offset, offset + URLS_PER_SITEMAP - 1);

    if (pageData) {
      for (const page of pageData) {
        const manga = page.manga as any;
        const slugData = manga.slug_map;
        
        if (slugData && slugData.length > 0 && slugData[0].slug) {
          const slug = slugData[0].slug;
          const lastmod = manga.created_at
            ? new Date(manga.created_at).toISOString().split('T')[0]
            : new Date().toISOString().split('T')[0];

          urls.push({
            loc: `${SITE_URL}/hentai/${slug}/${page.page_number}`,
            lastmod,
            changefreq: 'monthly',
            priority: page.page_number === 1 ? '0.6' : '0.4'
          });
        }
      }
    }

    const sitemap = generateSitemapXML(urls);

    return new Response(sitemap, {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'max-age=86400'
      }
    });
  } catch (error) {
    console.error(`Manga pages sitemap ${index} error:`, error);
    return new Response(generateSitemapXML([]), {
      headers: {
        'Content-Type': 'application/xml',
        'Cache-Control': 'max-age=3600'
      }
    });
  }
}

function generateSitemapXML(urls: SitemapUrl[]): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${urls.map(url => `  <url>
    <loc>${url.loc}</loc>
    ${url.lastmod ? `<lastmod>${url.lastmod}</lastmod>` : ''}
    ${url.changefreq ? `<changefreq>${url.changefreq}</changefreq>` : ''}
    ${url.priority ? `<priority>${url.priority}</priority>` : ''}
  </url>`).join('\n')}
</urlset>`;
}